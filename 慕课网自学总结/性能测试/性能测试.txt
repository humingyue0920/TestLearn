一 性能测试整体认知
1.性能测试要求:
a.熟悉Linux,Windows操作系统,掌握shell脚本
b.熟悉jvm调优,tomcat调优等基础策略(java)
c.mysql,掌握javascript,Python,java至少一门编程语言
d.至少一年左右独立性能测试实践经验
e.压测工具,jmeter,loadrunner 常见的分析调优工具,visualvm,yourkit,jps,jstat(java监控命令)
JVisualVM 简介:https://www.cnblogs.com/xifengxiaoma/p/9402497.html
f.熟悉性能测试整体流程,能够通过产品需求,梳理出性能测试点,并给出测试方案
g.http协议

2.性能测试技能树
a.开发语言--->建议java
b.操作系统--->linux 
c.数据库--->监控数据库--->调优
d.测试工具---->jmeter loadrunner
e.网络知识
f.业务知识

3.性能测试目的
发现性能瓶颈

4.移动端性能测试点
多并发下,耗电量,稳定性,client,弱信号下

5.性能测试分类(自动化测试归属于功能测试)
a.负载测试
通过逐步加压的方式,达到既定的性能阈值目标,阈值设定应是小于等于某个值,如CPU的使用率小于等于80%
例:前15分钟50个用户跑,系统比较稳定,一点一点加,然后100个,150个去跑
b.压力测试
通过逐步加压的方式达到系统的某些资源达到饱和值甚至是失效,找出是什么条件下把系统压崩溃,一点一点加,直到系统崩溃
c.并发测试
同一时间,多个虚拟用户同时去访问同一模块的同一功能,通常的测试方法是设置集合点
d.容量测试
一般是数据库层面的,目的是获取数据库的最佳容量能力,即容量预估,具体的测试方法为在一定的并发用户下,不同基础数据量下,观察数据库的处理能力,获取数据库的各项指标
容量测试前提,所有性能测试已经完成,未来业务可能会飞速发展,监控数据库性能
e.可靠性测试
又称疲劳测试或稳定性测试,系统在高压的情况下,长时间运行,系统是否稳定
例如:cpu使用率80%以上,7*24运行,发现系统瓶颈,最容易发现的问题是内存溢出和内存泄漏(系统长时间运行,底层垃圾回收不彻底导致)
f.异常测试
又称失败测试,是指系统架构方面的测试,如在负载均衡的架构中,要测试宕机,节点挂掉等情况系统的反映
例如:Nginx下面挂了3个tomcat,将一个tomcat弄挂,模拟宕机,节点挂掉,看其他两个tomcat的运行状况

6.性能测试工作流程
需求分析-->制定性能指标(tps,吞吐量)--->脚本开发-->场景设置--->性能监控-->测试执行(基准测试,比如第一轮测试,10个用户跑15分钟,看能发现哪些问题,多并发下应用程序对多线程逻辑处理问题能力,第二轮时间长一点)-->性能分析-->性能调优--->测试执行-->测试报告

7.常见系统应用分层架构
显示层                         web  Android  IOS  H5
逻辑控制层                              api
数据存储层   mysql(支持事务)  mongdb(不支持事务)  redies(存储到内存,读写速度快)
自底而上的一点一点做性能测试

8.性能测试指标定义
a.事务
客户端发送一个或多个请求，到客户端成功接收从服务端的响应
举例：客户端发送一个登陆请求，api层面对接口请求逻辑验证，到数据存储层面对用户名和密码进行校验，再返回给api，在返回给客户端一个成功或失败的结果，这称之为事务
最经典的例子：银行转账，多个请求组成
b.TPS（transition per second）
系统每秒成功处理的事务数
c.请求响应时间
从客户端发起请求，到客服端接收到服务端响应所耗费的时间
d.事务响应时间
从客户端发起一个或多个请求组成的事务，到客服端接收到服务端响应，整个过程所耗费的时间
e.并发定义
没有绝对意义上的并发
f.并发用户数
单位时间内，对系统发起请求的用户数量
g.吞吐量
在一次性能测试过程中，在网络传输上的数据量总和
h.吞吐率
单位时间内，网络上传输的数据量
吞吐率=吞吐量/传输时间
i.点击率
j.资源使用率
CPU，内存，io


二、性能测试工具篇
1.性能测试不推荐使用断言
2.if controller 如果控制器
例如：当用户满足什么条件去浏览什么商品，固定用户指定行为 如20%用户浏览食品类，30%用户浏览美食类，50%用户浏览服装类


三、Linux服务器监控性能测试
1.性能测试的目的：
自己服务器的配置不同，能够承受的最大任务数也不同，能够承受的压力也不同,性能测试前一定要搞清楚服务器的基础配置
2.服务器基础配置及性能测试范围（将Linux系统比作车间）
CPU ---》车间的工人，计算的东西，一些活都需要CPU完成    CPU越高，计算速度越低，CPU有瓶颈
内存  ---》相当车间的临时存储的一个仓库    读写存储速度快，数据不持久
磁盘 ---》  相当于车间的真正仓库   存储速度慢，数据永不丢失  绝大部分数据库，包括关系型数据库和非关系型数据库都刷到磁盘中，像mavencach这类存储在内存中
网络  ---》车间内的传送带或车间外的道路，起到传输的作用  跨服务器之间数据传输的高速通道  带宽
版本  ---》相当于车间的装修  版本不同，影响较大
在实际测试过程中，很难保证测试环境和生产环境的基础配置完全一致，此时就要保证应用系统的版本一致，包括数据库配置，jdk版本等等，版本不一致会导致很大的性能差异
3.当测试环境与生产环境的配置不同，我们该怎么办
通过多次压测来计算性能损耗  集群的概念
横轴表示服务器台数，纵轴表示性能指数，服务器越多，性能损耗越多
性能损耗指标计算方式：相同的脚本，相同的场景，相同的并发数，一切一切都相同，增加服务器台数
4.进程与线程（工作在Linux服务器上的两个重要概念）
进程：可以独立运行的一个程序，是系统分配资源和调度的基本单位
如：微信，QQ，PPT等，Linux系统下ps命令下的进程或使用top命令
线程：线程是进程的一个实体，是CPU调度和分派的基本单位，他是比进程更小的能给独立运行的基本单位，线程基本上不拥有系统资源，只拥有一点在运行过程中必不可少的资源，一个线程可以创建或撤销另一个线程
线程其实是在进程里面工作的，进程启动时声明和分配内存
5.进程与线程的区别
a.一个进程可以拥有多个线程，一个线程只能对应一个进程
b.一个进程会分配一个地址空间，进程与进程之间不共享地址空间，即内存，同一个进程下的不同线程之间共享父进程的地址空间
c.线程是进程最小的运行单位
d.线程与线程之间需要协作同步（加锁与解锁），而不同进程中的线程需要消息通信的办法进行协作同步
e.进程拥有资源的基本单位，而线程是调度和分派的基本单位（线程就是工作的，进程就是拥有资源的）
6.进程与线程的优缺点
a.进程的优点
每个进程之间相互独立，不影响主程序的稳定性，子进程的崩溃不会影响其他进程
通过增加CPU，就可以直接扩充性能
可以尽量减少线程之间加锁与解锁的影响，极大的提高性能
b.进程的缺点
与主系统进行交互，逻辑复杂
多进程开销调度大
c.线程的优点
程序逻辑和控制方式简单
所有线程之间可以共享内存和变量
线程方式消耗的总资源比进程少
d.线程的缺点
每个线程与主程序之间共用地址空间，最大内存地址受限
线程之间的同步和加锁不好控制
一个线程的崩溃，可能影响整个程序的稳定性

7.Linux监控命令
7.1 监控cpu
a.top命令 监控CPU及内存命令
top -h 帮助命令
top -p pid（s） 进程号，多个进程号之间用逗号隔开，只能在命令行下使用
任务区命名 （top命令输入完成按回车键后进入任务区命令行）
P 按CPU占有率倒叙排序
M 按内存大小倒叙排序
z  切换显示颜色
load average 平均负载率  最后一分钟，最后5分钟，最后十五分钟的平均队列长度  
单核中load average = 1时代表满负荷，多核即CPU核数*1代表满负荷
swap  交换分区 在Windows的虚拟内存，相当于是内存不够用，将一部分硬盘空间虚拟成内存使用，从而解决内存容量不足的情况
cached 缓存
buffer  缓冲区

b.vmstat 监控进程状态、内存、虚拟内存（swap）、磁盘io，CPU
vmstat 1 2 代表延迟1秒执行2次

c.mpstat 实时监控CPU 特点可以查看多核CPU中每个计算核心的统计数据
mpstat -P 0-CPU核数-1 不加此参数的时候默认展示所有CPU（注意大小写）
mpstat internal count  internal代表相邻两次采样间隔的时间，count代表采样的次数
mpstat没有参数的时候表示启动以后所有信息的平均值，当有internal时，第一行的信息自系统启动以来的平均值，从第二行开始，输出为前一个internal时间段的平均信息

7.2 监控内存
a.free  实时监控内存使用状况  total used free
free -h 用M来表示单位

7.3 监控网络
e.netstat 监控网络
-n  拒绝显示别名
-l 显示在监听的端口
-p  显示进程名称
-i  显示自动匹配接口名称
-c 每隔一个固定时间执行netstat命令(可加可不加)
-t  只显示tcp协议
-u  只显示udp协议
例如：netstat -nltp 
recv-Q/send-Q  发送和接收的队列长度
Iface:网络设备的接口名称
MTU:最大的传输单元,单位字节
RX-OK/TX-OK :已经准确无误的发送和接收的数据包
RX-ERR/TX-ERR:失败的发送和接收的数据包
RX-OVR/TX-OVR:接收和发送丢失数据包
RX-DRP/TX-DRP:接收和发送丢失数据包
-ntlp 主要看运行的端口有没有被监听,-i主要看传输的数据包大小以及正确错误的数据大小,达到网络监控的目的

7.4 监控磁盘
iostat 主要监控磁盘读写操作的统计信息，外加一些CPU信息
iostat -x 加设备名称 1 2 1代表间隔时间 2代表次数
tps:一次io请求
kb_read/s kb_wrtn/s:每秒钟读写的数据大小
kb_read/kb_wrtn:读写数据的总数
rrqm/s wrqm/s:每秒钟进行默质的读写操作
r/s w/s:每秒钟完成的读io设备的次数及写的次数
rkb/s wkb/s:每秒钟读的字节数
avgrq-sz:每次进行io操作的数据大小
avgqu-sz:平均io队列长度
await:平均每次设备io等待时间,单位毫秒
r_await/w_await
svctm:平均每次设备时间
%Util:一秒钟有%多少时间用于io操作,io操作繁忙程度,越大越不好,查看瓶颈
重点关注:kb_read/s kb_wrtn/s,%Util即可

7.5 万能命令 sar
7.6 Linux进程追踪命令 strace
7.7 Linux监控工具nmon的使用
绿色的都是可执行文件
创建nmon文件意义在于在任何文件夹下输入./nmon就可以执行文件
nmon -f -F demo.nmon -s 1 -c 10 -t  每隔1s执行10次，并且输出的文件名称为demo.nmon
-f必填参数，必须放在第一个
-F 可以自定义输出文件名称
-s 采集的频率，即间隔多久
-c 采集的次数
-t  输出最消耗资源的进程数据

四.数据驱动性能测试
参数化:推荐使用数据库来做参数化,完全用csv存在弊端,做分布式时不方便
crontab后续持续关注
逻辑控制器:分流 通常采用if控制器
看着视频中的文件是将数据库与csv data set config 连用,在csv文件中添加id,写了四个
这并不能解决我们的问题,1.加入数据量超过一万时,我们一个一个去添加?这是不现实的  2.同样存在了10台服务器上,我们一个一个去拷贝这个文件?
解决办法:直接将sql中的字段导入到csv文件中
第一种方式和第二种方法两种运行方式本质上完全不同,循环控制器是一个线程组跑的,意味着并不是并发,第一种在多个线程组下运行,可以做到并发,在做性能测试的时候要用第一种方式

五.数据库架构设计
5.1 数据库性能测试目的及范围
目的:发现数据库性能瓶颈
范围:sql慢查询(也是最主要的):主要针对select相关语句,有没有符合规范,有没有添加索引,也包含insert,注意insert写法,写法决定了写入速度的快与慢
     资源使用率:所有服务器端都存在资源使用率
     数据库架构的合理性
     数据库的性能指标
5.2 数据库的常用架构
1.一主多从(一台主数据库,多台从数据库,读写分离)
master主要负责写入和更新，为什么没有删除操作呢，因为不会真正的物理删除，is_flag的标志，从库主要负责读即select
优点:分担单台服务器或数据库的压力 
缺点:可能存在主从延时,造成的原因:网络情况,i/o,服务器设备等等
2.双机热备(Keepalive)
如何避免主从延时，读写都在一台服务器上
VIP：虚拟VIP 指向master（第一台服务器），数据同步复制到从库salve上
优点:1.避免了主从延时  2.当master挂掉之后，虚拟VIP立马指向slave，slave变成master，前端无感知
缺点:1.服务器压力过大，靠硬件扛  2.当第二台服务器slave也挂掉之后，VIP就没有指向了 3.当第一台服务器宕机之后，往第二天服务器写入的数据，第一台不会同步这些数据
实际使用过程中该如何抉择：当读写数据较少时,多数据较多,采用一主多从,反之采用双机热备
5.3 主从同步的原理
1.master和slave在两台数据库服务器上
2.master将所有的改变记录存到一个二进制文件中(brinary log)中
3.slave将brinary log event文件中记录的事件全部赋值到relay log中
4.slave执行relay log中语句
5.4 数据库分库分表的拆分方法
1.拆分的原因
单表或单库量太大,硬件不能升级或无法升级
2.拆分方法
业务拆分
垂直拆分
水平拆分

六. mysql性能测试
6.1 mysql数据库介绍:mariaDB 
6.2 mysql重点监控指标
6.2.1 QPS: queries per seconds 每秒钟查询量
如何获取QPS : show global status like 'questions'
queries/seconds  查询总数/查询时间
6.2.2 TPS:transaction per seconds 每秒钟处理的事物数
TPS = (com_commit + com_rollback)/seconds  提交事物数 + 回滚事物数
提交事物数 = show global status like 'com_commit'
回滚事物数 = show global status like 'com_rollback'
6.2.3 线程连接数(数据库特有的)
使用的最大连接数 : show global status like 'max_used_connections'
线程连接数 : show global status like 'Threads%'  即有多少个线程连接数据库
最大连接数 : show VARIABLES like 'max_connections'
当max_used_connections = max_connections 时,容易爆发错误
6.2.4 Query Cache 查询缓存
前提:在这期间,不会有insert和updata操作,会把select查询的结果缓存到内存中,查询速度快
如何开启查询缓存 :具体见PPT
6.2.5 Query cache 命中率
如何查询:show global status like 'Qcache%'
计算公式:Query_cache_hits = (Qcache_hits/(Qcache_hits+ Qcache_inserts))*100%
6.2.6 锁定状态
查询锁定状态 : show global status like '%lock%';
什么情况下会造成表锁:当update语句的where条件字段设定未用上索引或用某些索引还是不能确定要操作多少行数据,
这个时候会进行表锁,只有本线程可以对该表进行操作,别的线程不可以,例如读写,避免了脏读,等到该线程操作完才会释放该表,保持了数据一致
innodb_row_lock_waits行锁:自己知道自己要操作这行数据,不让别人操作这行数据
Table_locks_waited/table_locks_immediate   当值越大阻塞越严重
6.2.7 主从延时
查询主从延时:show slave status

6.3 慢查询
如何开启慢查询:两种方式
方式1:直接在mysql客户端,输入show VARIABLES like '%query%';找到slow_query_log将其修改为on即可
方式2:修改etc/my.cnf文件,将slow_query_log=1即可
slow_query_log_file 存放慢查询日志目录
slow_query_time 设定慢查询时间
如何将未使用索引的查询语句也记录到慢查询日志中:
同以上的两种方式,将log_queries_not_using_indexes = 1或on即可

6.4 慢查询日志分析
mysqldumpslow --h 查询帮助文档
-s 按照某种方式排序
    l:lock time 锁定时间
    r:rows sent 返回记录
    t:query time 查询时间
    al:average lock time 平均锁定时间
    ar:average rows sent 平均返回记录
    at:average query time 平均查询时间
    c:count 计数    
-t n 返回前n条数据
-g 正则匹配

6.5 sql语句性能分析
方法:查询语句前加入explain即可
字段分析:id
type:性能最好的三个:system,const,eq_ref 
性能最差的三个:index_merge,index,all
row:检索的行数

6.6 mysql存储引擎
6.6.1 MyISAM
优点:读的性能比innodb快很多 索引与数据分开,使用了压缩,从而提高了内存效率
缺点:不支持事务 写入数据的时候会直接全表锁 没有行锁
6.6.2 innodb
优点:支持事务 支持外键 支持行级锁
缺点:不支持全文索引  行锁并不绝对,当不确定操作多少行的时候会全表锁  索引与数据是紧密捆绑的,没有使用压缩导致体积庞大

6.7 实时监控数据库性能工具
6.7.1 orzdba
6.8 MySQL集群监控工具介绍






















